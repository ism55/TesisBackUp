En este capítulo se describirán el hardware y software empleados para la programación del firmware de la tarjeta de desarrollo seleccionada para el prototipo. Además, se mostrarán los resultados alcanzados durante este proceso.


\section{Detalles de software}

El sistema de acceso remoto se desarrolló sobre un microcontrolador ESP-8266 12-E, utilizando la tarjeta de desarrollo Wemos para el prototipo de este trabajo.

Para el desarrollo del sistema se utilizó como herramienta de programación el Kit de Desarrollo de Software (SDK) ESP-8266 NON-OS SDK de Espressif en lenguaje C, usando el PlatformIO IDE de Atom versión 1.38.1, compilado con GCC (GNU) 4.8.2. Esta información está resumida en la tabla \ref{TAB:software}. 


\begin{table}[H]
	
	\caption{Especificaciones de software}
	\label{TAB:software}
	
	\begin{center}
		\begin{tabular}{|c|c|}
			\hline
			\multicolumn{ 2}{|c|}{\textbf{Atom PlatformIO IDE}} \\
			\hline
			SDK & Espressif ESP-8266 NON-OS SDK v2.1.0 \\
			\hline
			Lenguaje &          C \\
			\hline
			Compilador & GCC (GNU) 4.8.2 \\
			\hline
			IDE & Atom PlatformIO IDE v1.38.1 \\
			\hline
		\end{tabular}  
	\end{center}
\end{table}

\subsection{Configuración del IDE Atom PlatformIO}

Al ejecutar el programa, se observará una pantalla como la indicada en la figura \ref{fig:atom1}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{img/atom_1}
	\caption{Ventana principal del IDE Atom PlatformIO}
	{1. Opción de creación de nuevo proyecto.}
	\label{fig:atom1}
\end{figure}


En la ventana principal se selecciona la opción de nuevo proyecto, identificada en la sección 1 de la figura \ref{fig:atom1}. De esta manera el IDE pondrá a disposición del usuario todas las librerías contenidas en el SDK. Para lograr esto, se configuran los parámetros según la figura \ref{fig:atom3}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{img/atom_3}
	\caption{Creación de nuevo proyecto}
	{1. Nombre del proyecto.\\
	2. Selección de microcontrolador. (Para este proyecto se usará Espressif ESP8266 12-E). \\
	3. Selección de framework de desarrollo. (En este caso Non-OS SDK).\\}
	\label{fig:atom3}
\end{figure}


Hecho esto, se podrá programar el microcontrolador en lenguaje C a través del IDE Atom PlatformIO. 

\subsection{Diseño de página web}

En cuanto al diseño de la página web; se desarrolló este código a través del editor de texto Brackets versión 1.14, ya que este trae soporte en tiempo real para modificaciones del archivo HTML y los diversos scripts. Las versiones de software utilizadas para esta sección se encuentran indicadas en la tabla \ref{TAB:paginaweb}. 

Posteriormente, el código fuente generado para la página web, (ver anexo: Código fuente web),  fue agregado al programa del sistema embebido como una cadena de caracteres, generando una página inicial para el servidor que se establecerá. 


\begin{table}[H]
	
	\caption{Especificaciones del software empleado en la página web.}
	\label{TAB:paginaweb}
	
	\begin{center}
		\begin{tabular}{|c|c|}
			\hline
			\multicolumn{ 2}{|c|}{\textbf{PÁGINA WEB}} \\
			\hline
			Editor & Brackets versión 1.14 \\
			\hline
			HTML &          versión 5 \\
			\hline
			CSS & versión 3 \\
			\hline
			Javascript & versión ECMAScript 2016 (1) \\
			\hline
			jQuery & versión 3.4.1 (1) \\
			\hline
			
		\end{tabular}  
	{\\(1). Estas versiones de Javascript y jQuery dependerán del navegador utilizado, ya que automáticamente se tomará la más actualizada que posea el sistema.}
	\end{center}
\end{table}


\subsection{Aplicación Android}

El prototipo propuesto en este trabajo cuenta con una interfaz ejecutable en dispositivos Android con sistema operativo Oreo o superior. 

La aplicación basada en el SDK de Android fue desarrollada en el entorno de programación Android Studio en lenguaje Java. Esta información está resumida en la tabla \ref{TAB:android}. El código fuente de esta aplicación está incluido en el Anexo: Código de fuente Android.


\begin{table}[H]
	
	\caption{Especificaciones de software}
	\label{TAB:android}
	
	\begin{center}
		\begin{tabular}{|c|c|}
			\hline
			\multicolumn{ 2}{|c|}{\textbf{APLICACIÓN ANDROID}} \\
			\hline
			SDK & Android \\
			\hline
			Lenguaje &        Java \\
			\hline
			IDE & Android Studio v3.5 \\
			\hline
			API & 28 \\
			\hline
			Sistema Operativo & Android Oreo (8.1) \\
			\hline
		\end{tabular}  
	\end{center}
\end{table}



\section{Detalles de hardware}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.9]{img/fotoesp82662}
	\caption{Placa del microcontrolador ESP-8266.}
	\label{fig:fotoesp8266}
\end{figure}


Las características de hardware del sistema embebido utilizado para el diseño del prototipo pueden verse en la tabla \ref{TAB:hardware1}. Es importante mencionar que estos datos fueron obtenidos desde la información grabada en la placa (figura \ref{fig:fotoesp8266}) y desde la información técnica proporcionada por Espressif en \cite{esp1}.



\begin{table}[H]
	
	\caption{Especificaciones de hardware de la tarjeta de desarrollo.}
	\label{TAB:hardware1}
	
	\begin{center}
		\begin{tabular}{|c|c|}
			\hline
			\multicolumn{ 2}{|c|}{\textbf{HARDWARE}} \\
			\hline
			Tarjeta de desarrollo &      LOL1n \\
			\hline
			Microcontrolador & ESP-8266 12-E \\
			\hline
			RAM & 80kB \\
			\hline
			Flash & 4MB \\
			\hline
			Oscilador & 80MHz\\
			\hline
			Procesador & Xtensa Tensilica L106 \\
			\hline
			WiFi & 892.11b/g/n \\
			\hline
			ISM &     2,4GHz \\
			\hline
			PA &     +25dBm \\
			\hline
			
		\end{tabular}  
	\end{center}
\end{table}


Para establecer la comunicación entre el disposito ESP8266 y el microcontrolador del brazo robot, es necesario enlazar el puerto serial de ambos integrados. A continuación se muestra el diagrama esquemático de conexión de la tarjeta de desarrollo ESP-8266 con el dsPIC30F3011 del controlador del brazo robot en la figura \ref{fig:montajetesis1}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/MontajeTesis}
	\caption{Esquemático de conexión entre ESP-8266 y dsPIC30F3011}
	\label{fig:montajetesis1}
\end{figure}

Una vez establecidos y configurados todos los parámetros del prototipo, se instaló el hardware sobre una tarjeta de prototipos tipo stripboard a modo de producto final de este trabajo. Este circuito puede observarse en la figura \ref{fig:montajecookie}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/circuito_final}
	\caption{Montaje del prototipo.}
	{LED 1. LED indicador de comunicación.\\
	LED 2. LED indicador de encendido.
}
	\label{fig:montajecookie}
	
\end{figure}


\section{Detalles de firmware}

\subsection{Programación en lenguaje Lua}

Lua se trata de un lenguaje interpretado con código base escrito en C, con semejanzas al lenguaje Python pero menos eficiente. Es de fácil aprendizaje y posee una forma de programación intuitiva para el usuario no experto. Es decir, es un lenguaje diseñado para aplicaciones poco complejas ya que se encuentra en desarrollo. Su puesta en marcha requiere una modificación del bootloader del microcontrolador, debiendo cargar al dispositivo un archivo binario previo con los módulos que desean ser utilizados. Esto a su vez ofrece pocas opciones para el manejo de memoria y de los periféricos a un modo mejor optimizado. \cite{Online:lua}. Por estos motivos expuestos, no será utilizado para la programación de este prototipo.

\subsection{Programación en lenguaje Simba}

Simba es un sistema operativo de tiempo real (RTOS) escrito en lenguaje C que surgió como una opción para programar el microcontrolador ESP8266. Es soportado por el IDE Atom PlatformIO y ofrece ventajas en cuanto a su fácil aprendizaje y a un mayor potencial de las aplicaciones que pueden generarse. Sin embargo, este entorno aún se encuentra en desarrollo y por lo tanto presenta muchos fallos en torno a las librerías y drivers no implementados. Además, las librerías inherentes al firmware del dispositivo no están dispuestas para modificación del programador y su compilación es lenta en comparación al la realizada en lenguaje C. \cite{Online:simba}. Por este motivo no será utilizado en este prototipo.

\subsection{Programación en lenguaje C}

\subsubsection{Kit de desarrollo de software: Espressif RTOS ESP-8266 SDK}

SDK, en inglés Software Development Kit (Kit de Desarrollo de Software). Es un compilado de herramientas necesarias para desarrollar aplicaciones específicas para el entorno deseado. 

El ESP8266 ofrece la capacidad de ser programado basado en un sistema operativo de tiempo real (RTOS). Este SDK proporcionado por Espressif, se trata de una adaptación del entorno de código libre freeRTOS (página oficial:  https://www.freertos.org/). 

Un sistema operativo de tiempo real es una herramienta eficiente para dispositivos con poca capacidad de procesamiento. Es decir, aquellos dispositivos que no cuentan con una variedad de núcleos o kernels. RTOS trata de implementar en estos microsistemas una similud de comportamiento de múltiples unidades de procesamiento aún estando contenidas en un solo núcleo. Lo cuál es una ventaja importante para la implementación de sistemas de mayor complejidad de código. 

La lógica funcional del método de programación RTOS es mediante establecimiento de tareas e interrupciones controladas por órden de prioridad y por el timer principal del sistema. Esto genera la apariencia de estar procesándose múltiples tareas en un mismo instante. No obstante, estas tareas o 'tasks' están limitadas por el factor de tiempo que dicta el procesador. \cite{Online:rtos}.

Este sistema operativo hace uso de todas las virtudes del procesador a una mayor escala que las otras opciones de programación (Simba, Lua, C), debido a que debe aprovechar todos los recursos para permitir la libre ejecución de la mayor cantidad de tareas; esto ocasiona que su compilación sea relativamente más lenta que el caso de Non-OS.

Debido a que en este prototipo no es de interés la implementación de tareas para el manejo de la comunicación del brazo robot, ya que puede hacerse con un mismo núcleo; no se considerará para la programación de este proyecto.  

\subsubsection{Kit de desarrollo de software: Espressif NON OS ESP-8266 SDK}

Se trata de un kit diseñado por la empresa Espressif para desarrollar software en dispositivos sin sistema operativo. En ella tiene las librerías de mayor importancia para la configuración y uso del ESP-8266. \cite{esp1} \cite{esp2} \cite{esp3} \cite{esp4} 

El SDK NON-OS provee un conjunto de interfaces de programación de aplicaciones (API) para las funcionalidades del núcleo ESP-8266, como recepción/ transmisión de datos a través de Wi-Fi, funciones para el manejo de TCP/IP, funciones para la interfaz de hardware y el manejo básico del sistema.

Las librerías más importantes incluídas dentro del SDK son: osapi.h, user\_interface.h, driver/uart.h, espconn.h, gpio.h, eagle\_soc.h.

%\section{Uso de librerías en lenguaje C}

Para el desarrollo de aplicaciones con manipulación de caracteres y cadenas es necesario utilizar la librería \textit{string.h}. Esta librería está incluída en el estándar de lenguaje C, ya que es de uso común. 

Incluye funciones para manipulación de arreglos de caracteres. Propiamente, define un tipo de variable, un macro y varias funciones para manipulación de arreglos y cadenas. Algunas de las funciones utilizadas comúnmente son: \textit{strtok, strcmp, strncmp, memset, strlen, strcpy, strncpy}, entre otros. 


Otra librería importante que sirve soporte a \textit{string.h} es \textit{stdlib.h}, debido a que posee las funciones necesarias para la conversión de caracteres en números, utilización de memoria dinámica para la generación de listas, colas y demás algoritmos de organización y posicionamiento de memorias. También está incluída en el lenguaje C estándar y es considerada de uso común. A grandes rasgos, esta librería define cuatro tipos de variables, múltiples macros, y varias funciones de uso general; funciones como: \textit{atoi, atof, atol, malloc, free, abort, abs, rand}, entre otras; son las más utilizadas.

%\section{Kit de desarrollo de software: Espressif NON OS ESP-8266 SDK}


%En el caso del Espressif NON OS ESP-8266 SDK, 




\subsection{osapi.h}
Esta librería realiza una re-definición de algunas de las funciones más importantes de la librería string.h y algunas funciones para manejo del timer. Por lo tanto, es una librería importante para el manejo de cadena de caracteres. 

Algunas de las funciones incluídas en esta librería incluyen el prefijo 'os', que simboliza que estas dan una respuesta de debug vía puerto serial al momento de utilizarlas. 

Para deshabilitar estos comandos, es necesario escribir previo a todas las declaraciones del programa principal: 'system\_set\_os\_print(0)'. Y con esto pueden utilizarse sin inconvenientes las funciones con comandos 'os'.

Visto en lenguaje C:

\begin{verbatim}
void ICACHE_FLASH_ATTR
user_rf_pre_init(void)
{
	system_set_os_print(0);
}
\end{verbatim}

Nótese que se hace el llamado de esta función dentro de la definición de 'user\_rf\_pre\_init' debido a que esta se ejecuta primero que la función main, haciendo que se evite cualquier error inesperado con los comandos 'os'.

\subsection{user\_interface.h}

Contiene las definiciones de las estructuras para configurar el Wi-Fi en modo estación o punto de acceso.

Esto es, la definición de los macros: 'NULL\_MODE', 'STATION\_MODE', 'SOFTAP\_MODE' y 'STATIONAP\_MODE'; que permiten configurar los modos de funcionamiento del Wi-Fi.

También define la estructura asociada a la función 'wifi\_softap\_get\_config', quien es la función encargada de configurar todos los parámetros para establecer la conexión Wi-Fi.

\subsection{driver/uart.h}

Posee los macros y variables necesarias para la configuración del UART. Entre ellos, define la función 'uart0\_tx\_buffer', la cuál es de vital importancia para la transmisión de cadenas de caracteres vía puerto serial en este prototipo.

\subsection{espconn.h}

Define las estructuras para la creación del socket TCP o UDP, así como los prototipos y declaraciones de las funciones de la API correspondiente. Con estas funciones es posible establecer un servidor o cliente mediante solicitudes y respuestas.

Las funciones de interés en esta librería son: 'espconn\_connect', quien permite conectar al canal de comunicación una vez este sea creado con 'espconn\_create' y aceptado con la función 'espconn\_accept'.

Las funciones 'espconn\_disconnect' y 'espconn\_delete' son de utilidad para desconectar el canal previo a eliminarlo, y así de esta manera evitar la saturación de la comunicación servidor-cliente, ya que esta solo permite la creación de un máximo de 12 canales, pero manteniendo únicamente 4 en paralelo en constante comunicación. Esto genera un problema que se resuelve aplicando estas funciones de desconexión y borrado.

\subsection{gpio.h}

Contiene los prototipos y definiciones de las funciones que configuran los puertos de propósito general (GPIO). En concreto, las funciones que seleccionan un pin como entrada o salida, en modalidad baja o alta; entre otros parámetros.

\subsection{eagle\_soc.h}

Esta librería es, quizá, de las más importantes. En ella se definen los macros que permiten acceder a las múltiples funciones de los GPIO. 

Como puede observarse en la tabla \ref{TAB:registrosesp}, el ESP-8266 posee múltiples puertos de propósito general, por ello es necesario indicar el propósito de uso de cada GPIO deseado. 

\begin{table}[H]
	
	\caption{Registros de GPIO del ESP-8266. Fuente: Espressif.}
	\label{TAB:registrosesp}
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			{\bf FUNCTION 3} & {\bf FUNCTION 4} & {\bf AT RESET} & {\bf AFTER RESET} & {\bf SLEEP} \\
			\hline
			\textbf{GPIO0}&    CLK\_OUT &  oe=0, wpu &        wpu &       oe=0 \\
			\hline
			{\bf GPIO1} &    CLK\_RTC &   oe=0,wpu &        wpu &       oe=0 \\
			\hline
			{\bf GPIO2} &      U0TXD &   oe=0,wpu &        wpu &       oe=0 \\
			\hline
			{\bf GPIO3} &   CLK\_XTAL &   oe=0,wpu &        wpu &       oe=0 \\
			\hline
			{\bf GPIO4} &            &       oe=0 &            &       oe=0 \\
			\hline
			{\bf GPIO5} &            &       oe=0 &            &       oe=0 \\
			\hline
			{\bf GPIO6} &      U1CTS &       oe=0 &            &       oe=0 \\
			\hline
			{\bf GPIO7} &      U1DXD &       oe=0 &            &       oe=0 \\
			\hline
			{\bf GPIO8} &      U1RXD &       oe=0 &            &       oe=0 \\
			\hline
			{\bf GPIO9} &     HSPIHD &       oe=0 &            &       oe=0 \\
			\hline
			{\bf GPIO10} &     HSPIWP &       oe=0 &            &       oe=0 \\
			\hline
			{\bf GPIO11} &      U1RTS &       oe=0 &            &       oe=0 \\
			\hline
			{\bf GPIO12} &      U0DTR &  oe=0, wpu &        wpu &       oe=0 \\
			\hline
			{\bf GPIO13} &      U0CTS &  oe=0, wpu &        wpu &       oe=0 \\
			\hline
			{\bf GPIO14} &      U0DSR &  oe=0, wpu &        wpu &       oe=0 \\
			\hline
			{\bf GPIO15} &      U0RTS &  oe=0, wpu &        wpu &       oe=0 \\
			\hline
			DEEPSLEEP & BT\_XTAL\_EN &  oe=1, wpd &  oe=1, wpd &       oe=1 \\
			\hline
		\end{tabular}  
	\end{center}
	
\end{table}


Los registros descritos en la tabla \ref{TAB:registrosesp} pueden observarse mejor en la figura \ref{fig:nodemcupins}, donde se muestra el pinout de este sistema embebido. La descripción de estos parámetros está descrita con detalle en la hoja de datos \cite{esp4}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{img/nodemcu_pins}
	\caption{Pinout de sistema embebido con microcontrolador ESP8266.}
	\label{fig:nodemcupins}
\end{figure}

La importancia de la correcta definición de los puertos de propósito general en este dispositivo dependerá de la aplicación que desea hacerse. En el caso del prototipo que se propone, es necesario definir el periférico de UART para operar con la comunicación serial hacia el brazo manipulador. Además, es necesario definir algunos pines como salida para visualización del comportamiento del programa y sin que estos interfieran con otros periféricos.

\section{Contenido del programa}
El programa consta de cinco archivos: user\_main.c, user\_config.h, funciones.h, funciones.c, pagina.h. Organizados de esta manera para lograr una compilación fluida con archivos de menor tamaño y para que sea un código en el que sea más sencillo modificar una instrucción sin afectar el proyecto. Es decir, sea un código más sencillo de leer para el programador.

\subsection{Diagrama de flujo del programa}
En la figura \ref{fig:flowchart} se observa un esquema general de funcionamiento que indica cómo es la ejecución de los archivos del programa.
\begin{figure}[H]

	\includegraphics[scale=0.25]{img/flowchart}
	\caption{Diagrama de flujo del funcionamiento del programa.}
	\label{fig:flowchart}
\end{figure}


\subsection{user\_main.c}
En el archivo user\_main.c se encuentra el segmento de código principal y las rutinas de configuración del módulo para su operatividad.

\subsection{user\_config.h}
En el archivo user\_config.h se define el mapeo de pines de la tarjeta de desarrollo de acuerdo a la identificación de las GPIO según el SDK. También se definen algunas variables utilizadas para generar las tramas de comunicación y las variables para SSID y contraseña de la red WiFi.

\subsection{funciones.h y funciones.c}

En el archivo funciones.h se encuentran los prototipos de todas las funciones y el llamado de las librerías de mayor importancia desde el SDK, indicadas a continuación.

\begin{verbatim}
#include "stdlib.h"
#include "stdio.h"
#include "osapi.h"
#include "user_interface.h"
#include "driver/uart.h"
#include "ets_sys.h"
#include "c_types.h"
#include "espconn.h"
#include "mem.h"
#include "gpio.h"
#include "eagle_soc.h"
\end{verbatim}

 En el archivo funciones.c están todas las definiciones de las funciones utilizadas en el programa. Además, están declaradas las variables y estructuras globales necesarias.

\subsection{pagina.h}
Este archivo contiene dos variables tipo char que contienen en una cadena el código HTML de la página web y la cadena de respuesta ante una solicitud exitosa.

\subsection{Compilación del programa a través de Atom PlatformIO IDE}
Al compilar el código y cargarlo en el microcontrolador, el IDE muestra los valores totales del consumo de memoria de esta aplicación, como se observa en la figura \ref{fig:compilado}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{img/compilado}
	\caption{Compilado del programa.}
	\label{fig:compilado}
\end{figure}

\section{Funcionamiento de la comunicación cliente-servidor}\label{SEC:funcionamiento}

El programa principal consta del establecimiento de un servidor TCP incluído en el microcontrolador ESP8266 que espera una solicitud HTTP proveniente del browser al que se tiene acceso como cliente. Este browser puede ser cualquier navegador de internet actualizado (Chrome, Firefox, Opera).

TCP (protocolo de control de transmisión) es un protocolo que opera en la capa de transporte a través de IP (capa de internet). El interés principal para la utilización de este protocolo es que garantiza el envío y recepción de paquetes de datos proporcionando una transferencia de datos fiable con control de flujo, ya su vez comprueba automáticamente cada comunicación con el servidor los números de secuencia, mensajes de reconocimiento y temporizadores.

UDP, en cambio, no se considera un protocolo fiable ya que contempla buscar el mejor enlace para la transmisión de la información, pero no garantiza que esta llegue a su destino.

Para este prototipo propuesto, se utilizará TCP ya que es necesario que la información comunicada entre cliente-servidor sea en tiempo real; y por este motivo debe asegurarse que esta siempre se pueda transmitir.

El funcionamiento específico se resume en la figura \ref{fig:httpserverclient}, que muestra la comunicación cliente-servidor al momento de solicitar un comando.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{img/http_server_client}
	\caption{Ejemplo de comunicación cliente- servidor.}
	\label{fig:httpserverclient}
\end{figure}

Esto se entiende de la siguiente manera:

\begin{itemize}
	\item El cliente se conecta al servidor y solicita la página web
	\item El servidor responde 200 OK (comunicación exitosa) y envía la página web.
	
	\item El cliente realiza una modificación en la página
	
	\item El servidor recibe la trama y responde 200 OK.
\end{itemize}

\subsection{Pseudocódigo del programa del prototipo}

\begin{center}
	\begin{algorithm}[H]
		Programa principal\;
		\Begin{
			Configurar UART\;
			Configurar GPIO\;
			Encender LED D4\;
			Configurar WiFi\;
			Crear servidor TCP\;
			
			\While{1==1}{		
				//Esperar solicitud TCP\;
			}%end while
			
		}%end begin	
	\end{algorithm}
	
\end{center}


\begin{center}
	\begin{algorithm}[H]		
		Función de desconexión\;
		\Begin{
			Borrar canal TCP\;
			Crear nuevo canal TCP. //Esperar\;
		}%end begin
		
	\end{algorithm}
	
\end{center}


\begin{center}
		\resizebox{11cm}{!} {
	\begin{algorithm}[H]		
		Interrupción Wifi\;
		\Begin{
			
			\If{Conexión a página}{
				Abrir canal TCP\;
				Responder 200 OK\;
				Encender LED D2 al iniciar carga\;
				Apagar LED D2 al culminar carga\;
				// Este canal no requiere ser desconectado.
			}
			\While{Canal abierto}{
				\Switch{Solicitud}{
					\Case{Mover motor}{
						Recibir cadena HTTP\;
						Procesar información\;
						Calcular el valor del movimiento\;
						Construir la trama\;
						Enviar al puerto serial\;
						Desconectar canal TCP\;
					}
					\Case{Configurar parámetro}{
						Recibir cadena HTTP\;
						Procesar información\;
						Calcular el valor del parámetro\;
						Construir la trama\;
						Enviar al puerto serial\;
						Desconectar canal TCP\;
					}
					\Case{Configurar constantes de calibración}{
						Recibir cadena HTTP\;
						Procesar información\;
						Calcular el valor de la constante\;
						Cambiar el valor de la constante\;
						Desconectar canal TCP\;
					}
					
				}%end switch
			}%end while
		}%end begin
		
	\end{algorithm}
}
\end{center}


En la tabla \ref{TAB:wifi}, se especifica la información de la señal WiFi sobre la que se crea el servidor. Este es creado en el puerto 8266 sobre la IP 192.168.4.1 vía la señal WiFi emitida desde el microcontrolador. Esta comunicación se realiza a 2.4GHz y 54Mbps y solo puede crear 4 canales de comunicación TCP en paralelo, por ese motivo debe desconectarse después de cada comunicación para evitar la saturación del servidor.

\begin{table}[H]
	\label{TAB:wifi}
	\caption{Información sobre la conexión WiFi}
\begin{center}
		
\begin{tabular}{|c|c|}
	\hline 
	SSID & ESP8266-WiFi \\
	\hline 
	Contraseña & esp123456 \\
	\hline 
	Dirección MAC & e0:e6:2e:7b:d4:7b \\ 
	\hline 
	Dirección IP & 192.168.4.2 \\ 
	\hline 
	Puerta de enlace & 192.168.4.1 \\ 
	\hline 
	Máscara de subred & 255.255.255.0 \\ 
	\hline 
	DNS & 192.168.4.1 \\ 
	\hline 
	Frecuencia & 2.4 GHz \\ 
	\hline 
	Velocidad de conexión & 54 Mbps \\ 
	\hline 
	Seguridad & WPA/ WPA2 PSK \\ 
	\hline 
	Dirección IPv6 & fe80::525c:d653:7ba:b7cb \\ 
	\hline 
\end{tabular} 

\end{center}
\end{table}

Para procesar cada string se utiliza la librería \textit{string.h} (declarada dentro de \textit{osapi.h} en el SDK) que contiene múltiples funciones para el manejo de cadenas. 

La cadena recibida en cada comunicación se trata de una petición HTTP con método GET que posee la siguiente estructura:

\begin{verbatim}
GET /?comando=valor HTTP/1.1
Host: 192.168.4.1:8266
Connection: keep-alive
Accept: */*
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)...
Referer: http://192.168.4.1:8266/
Accept-Encoding: gzip, deflate
Accept-Language: es-ES,es;q=0.9,en;q=0.8
\end{verbatim}

Una vez recibida la cadena tras una solicitud, es comparada con la función \textit{strncmp}. Esta es usada para encontrar una coincidencia dentro de la lista de comandos permitidos que se encuentran en la tabla \ref{TAB:comandosESP}. 


\begin{table}[H]
	\caption{Comandos aceptados en las solicitudes HTTP.}
	\label{TAB:comandosESP}
\begin{center}
		\resizebox{13cm}{!} {
	
\begin{tabular}{|c|l|l|}
	\hline
	{\bf COMANDO} & {\bf STRING} & {\bf FUNCIÓN} \\
	\hline
	cmd00 & GET / HTTP/1.1 & Solicitud de la página desde el browser \\
	\hline
	cmd1 & GET /?num1 & Mover motor 1 \\
	\hline
	cmd2 & GET /?num2 & Mover motor 2 \\
	\hline
	cmd3 & GET /?num3 & Mover motor 3 \\
	\hline
	cmd4 & GET /?num4 & Mover motor 4 \\
	\hline
	cmd5 & GET /?num5 & Mover motor 5 \\
	\hline
	cmd6 & GET /?num6 & Mover motor 6 \\
	\hline
	cmd7 & GET /?gripon & Habilitar pinza neumática \\
	\hline
	cmd8 & GET /?gripoff & Deshabilitar pinza neumática \\
	\hline
	cmd9 & GET /?PR1  & Configurar timer PR1 \\
	\hline
	cmd11 &  GET /?Kp1 & Factor proporcional PID 1 \\
	\hline
	cmd12 &  GET /?Ki1 & Factor integral PID 1 \\
	\hline
	cmd13 &  GET /?Kd1 & Factor derivativo PID 1 \\
	\hline
	cmd14 &  GET /?Kp2 & Factor proporcional PID 2 \\
	\hline
	cmd15 &  GET /?Ki2 & Factor integral PID 2 \\
	\hline
	cmd16 &  GET /?Kd2 & Factor derivativo PID 2 \\
	\hline
	cmd17 &  GET /?Kp3 & Factor proporcional PID 3 \\
	\hline
	cmd18 &  GET /?Ki3 & Factor integral PID 3 \\
	\hline
	cmd19 &  GET /?Kd3 & Factor derivativo PID 3 \\
	\hline
	cmd20 & GET /?Kpro1 & Constante de calibración proporcional 1 \\
	\hline
	cmd21 & GET /?Koffset1 & Constante de calibración de offset 1 \\
	\hline
	cmd22 & GET /?Kpro2 & Constante de calibración proporcional 2 \\
	\hline
	cmd23 & GET /?Koffset2 & Constante de calibración de offset 2 \\
	\hline
	cmd24 & GET /?Kpro3 & Constante de calibración proporcional 3 \\
	\hline
	cmd25 & GET /?Koffset3 & Constante de calibración de offset 3 \\
	\hline
	cmd26 & GET /?puente1=ON & Habilitar Puente H 1 \\
	\hline
	cmd27 & GET /?puente1=OFF & Deshabilitar Puente H 1 \\
	\hline
	cmd28 & GET /?puente2=ON & Habilitar Puente H 2 \\
	\hline
	cmd29 & GET /?puente2=OFF & Deshabilitar Puente H 2 \\
	\hline
	cmd30 & GET /?puente3=ON & Habilitar Puente H 3 \\
	\hline
	cmd31 & GET /?puente3=OFF & Deshabilitar Puente H 3 \\
	\hline
\end{tabular}  

}

\end{center}\end{table}


De haber una coincidencia, en esta solicitud es de principal interés obtener los parámetros \textit{comando=valor} para algunas peticiones. Como es el caso de los movimientos de los motores y la configuración de parámetros.

Para ello se utiliza la función \textit{strncpy} para copiar al menos 30 caracteres en una variable auxiliar y de esta manera manipular una cadena menor.

Una vez recortada la cadena, se utiliza la función \textit{strtok} para separar cada parte del mensaje en subvariables o tokens. Colocando como selector el caracter de espacio ' ' e igual '='.

El código del microcontrolador está, además de por comandos, estructurado por un total de catorce funciones que se ejecutan según sea el caso. Estas serán explicadas en los siguientes apartados.

\subsection{Función server\_recv}

\begin{table}[H]
	\centering
	\caption{Descripción de Función server\_recv.}
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & server\_recv(void *arg, char *pdata, unsigned short len) \\
		\hline
		Descripción:  & Función de respuesta ante recepción de información \\
		\hline
		Parámetros: & arg -- estructura espconn \\
		\hline
		& pdata -- informacion recibida \\
		\hline
		& len -- tamaño de información recibida \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func1}%
\end{table}%



Esta es principalmente la función de respuesta ante recepción de información en el servidor.\\

En ella se obtiene la cadena recibida en el canal TCP para la posteriór identificación de los comandos. Para esto, se realiza una evaluación de cadenas mediante la función \textit{strncmp} de la librería \textit{string.h} para buscar el identificador del comando.\\

Posteriormente, de acuerdo al resultado del comando, esta ejecutará una instrucción contenida en un bloque condicional único para cada caso.

\subsection{Función server\_sent}

\begin{table}[H]
	\centering
	\caption{Descripción de Función server\_sent.}
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & server\_sent(void *arg); \\
		\hline
		Descripción:  & Función de respuesta ante envío de información \\
		\hline
		Parámetros: & arg -- estructura espconn \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func2}%
\end{table}%


Función de callback cuando se envía algo desde el servidor. Esta función enciende un LED de notificación en el pin D2 de la tarjeta de desarollo. Además, con cada comunicación emitida parpadeará el LED D4.

\subsection{Función server\_discon}

\begin{table}[H]
	\centering
	\caption{Descripción de Función server\_discon}
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & server\_discon(void *arg); \\
		\hline
		Descripción:  & Función de respuesta ante desconexión \\
		\hline
		Parámetros: & arg -- estructura espconn \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func3}%
\end{table}%

Función de callback cuando se desconecta un canal TCP. Esta borra por completo el canal y vuelve a habilitar el servidor TCP en el puerto 8266, seguidamente apaga un led en el pin D4 de la tarjeta de desarrollo.

\subsection{Función server\_listen}

\begin{table}[H]
	\centering
	\caption{Descripción de Función server\_listen}
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & server\_listen(void *arg);\\
		\hline
		Descripción:  & Función de respuesta ante un servidor creado exitosamente \\
		\hline
		Parámetros: & arg -- estructura espconn \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func4}%
\end{table}%


Esta función se utiliza para declarar cuáles serán las funciones de callback para 'escuchar' las conexiones en el canal TCP. Para hacer esto, se utiliza las funciones \textit{espconn\_regist\_sentcb} y \textit{espconn\_regist\_disconcb} del NON-OS SDK.

\subsection{Función server\_recon}

\begin{table}[H]
	\centering
	\caption{Descripción de Función server\_recon}
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & server\_recon(void *arg, sint8 err); \\
		\hline
		Descripción:  & Función de respuesta ante un error en la creación del servidor\\
		\hline
		Parámetros: & arg -- estructura espconn \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func5}%
\end{table}%


Esta función se encarga de reconectar el servidor en caso de una falla en el establecimiento del canal TCP. Esto ocurre raramente. No obstante, se incluye como medida cautelar ante posibles errores en la comunicación.

\subsection{Función init\_tcp}

\begin{table}[H]
	\centering
	\caption{Descripción de Función init\_tcp.}
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & init\_tcp(uint32\_t Local\_port); \\
		\hline
		Descripción:  & Funcion para configurar el servidor \\
		\hline
		Parámetros: & Local\_port -- puerto donde se creara el socket \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func6}%
\end{table}%


Dentro de la estructura de configuración de la conexión, se define el apuntador, el tipo (TCP) y el puerto para establecer la conexión.

Luego, con la función \textit{espconn\_regist\_connectcb} de la librería \textit{espconn.h} se define el callback para 'escuchar' el servidor. 

Finalmente, para crear el servidor, se utiliza \textit{espconn\_accept} de la librería \textit{espconn.h} y se enciende un led en el pin D4 de la tarjeta de desarrollo.

\subsection{Función ap\_config\_func}

\begin{table}[H]
	\centering
	\caption{Descripción de Función ap\_config\_func}
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & ap\_config\_func();\\
		\hline
		Descripción:  & Funcion para configurar el WiFi \\
		\hline
		Parámetros: & none \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func7}%
\end{table}%


Esta función configura la conexión que realiza el microcontrolador por medio de la señal WiFi. Se selecciona el modo de punto de acceso (SOFTAP MODE) en donde se da valor a la SSID y contraseña de la conexión a establecer. Como SSID se colocó 'ESP8266-WiFi' y contraseña 'esp123456' con seguridad WPA/WPA2 PSK, como se indica en la tabla \ref{TAB:wifi}.

\subsection{Función gpio\_init}

\begin{table}[H]
	\centering
	\caption{Descripción de Función gpio\_init}
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & gpio\_init(); \\
		\hline
		Descripción:  & Configura los pines de proposito general\\
		\hline
		Parámetros: & none \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func8}%
\end{table}%


Esta función configura los pines D2 y D4 como salidas digitales. También configura el UART2 de 8 bits con bit de parada y 115200 baudios.

\subsection{Función mover\_motor}
\label{FUNC:movermotor}

\begin{table}[H]
	\centering
	\caption{Descripción de Función mover\_motor}
	\begin{tabularx}{\textwidth}{|L|L|}
		\hline
		Nombre de función: & void mover\_motor(int comando, char* recibido,float constante\_grados,float constante\_offset); \\
		\hline
		Descripción:  & Mueve el motor indicado con el parametro comando \\
		\hline
		Parámetros: & comando -- nombre del motor a mover \\
		\hline
		& recibido -- string recibido en el request de la pagina \\
		\hline
		& constante\_grados -- constante de calibracion para convertir la informacion a un valor binario \\
		\hline
		& constante\_offset -- constante de calibracion para corregir el error de bits \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabularx}%
	\label{tab:func9}%
\end{table}%


Esta función recibe la cadena y la separa por secciones para tomar su valor.

De la cadena recibida, toma los primeros 30 caracteres y se procesa como se explica a continuación:


\subsubsection{Información de la trama HTTP enviada por el cliente (Browser):} El cliente realiza un request GET cuya cabecera contiene lo siguiente:

\begin{verbatim}
GET /?num1=XXX HTTP/1.1
\end{verbatim}

En este mensaje el valor XXX debe ser aislado para ser procesado.
Esto se hace mediante la función \textit{strtok} de la libreria \textit{string.h}.
Se colocaran como selectores de token, los caracteres ' ' y '='.

\begin{verbatim}
1ra vez:
GET /?num1=XXX HTTP/1.1
   ^     token=GET
2da vez:
/?num1=XXX HTTP/1.1
      ^    token=/?num1

3ra vez:
XXX HTTP/1.1
   ^   token=XXX     y con esto ya se obtiene el valor de XXX.
\end{verbatim}

Una vez obtenido ese valor, este es convertido en entero con la función \textit{atoi} de la librería \textit{stdlib.h} o convertido en float con la función \textit{atof} (o en su defecto, la función personalizada \textit{myatof}). Seguidamente, se aplica la conversión según la expresión \ref{ec:convertirdigital} obtenida de la ecuación \ref{ec:convertiragrados}.

\begin{equation}\label{ec:convertirdigital}
Valor_{digital} = (\frac{Valor_{grados}}{K_{pro}}) - K_{offset}
\end{equation}

Una vez convertido el valor, este se desplaza 6 bits a la izquierda para ordenarlos.

Como se desea transmitir una trama como la indicada en la tabla \ref{TAB:estructura}, es necesario que el valor obtenido anteriormente se desplace 8 bits a la derecha para así dar valor al dato high. El dato low no tiene mayores modificaciones, así que esta función termina su trabajo enviando el arreglo con la instrucción \textit{uart0\_tx\_buffer} de la librería \textit{uart.h} del NON-OS SDK.

\subsection{Función mover\_motor\_2}

\begin{table}[H]
	\centering
	\caption{Descripción de Función mover\_motor\_2}
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & mover\_motor\_2(int comando, char* recibido); \\
		\hline
		Descripción:  & Mueve el motor indicado con el parametro comando \\
		\hline
		Parámetros: & comando -- nombre del motor a mover \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func10}%
\end{table}%


Esta función realiza la misma operación que \textit{mover\_motor} (\ref{FUNC:movermotor}). Sin embargo, la calibración de offset y proporcionalidad ya están predefinidas y no pueden cambiarse. Esto se hace para dar movimiento a los motores de la mano del robot (D, E, F).

\subsection{Funciones cambiar\_constante, parametro\_pid, puenteH}

\begin{table}[H]
	\centering
	\caption{Descripción de Función cambiar\_constante}
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & cambiar\_constante(char* recibido); \\
		\hline
		Descripción:  & Cambia la constante del motor indicado con el parametro comando \\
		\hline
		Parámetros: & recibido -- string recibido en el request de la pagina \\
		\hline
		& constante\_cambiada -- constante de calibracion cambiada \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func11}%
\end{table}%


\begin{table}[H]
	\centering
	\caption{Descripción de Función parametro\_pid}
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & parametro\_pid(int comando,char* recibido); \\
		\hline
		Descripción:  & Cambia la constante del motor indicado con el parametro comando \\
		\hline
		Parámetros: & comando -- parametro del PID a modificar\\
		\hline
		& recibido -- string recibido en el request de la pagina \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func12}%
\end{table}%


\begin{table}[H]
	\centering
	\caption{Descripción de Función puenteH }
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & puenteH(int comando,char* recibido,int instruccion); \\
		\hline
		Descripción:  & Modifica el parametro del Puente H \\
		\hline
		Parámetros: & comando -- parametro del PID a modificar \\
		\hline
		& recibido -- string recibido en el request de la pagina \\
		\hline
		& instruccion -- Indica el encendido o apagado \\
		\hline
		Resultado:  & none \\
		\hline
	\end{tabular}%
	\label{tab:func13}%
\end{table}%


Estas funciones se utilizan para cambiar el valor de las constantes de calibración presentes en los motores A, B y C (cambiar\_constante). También configura los parámetros del PID como Kp, Ki, Kd de los motores A, B y C (parametro\_pid). El registro PR1 del timer del controlador y por último habilita o deshabilita los puentes H de los motores A, B y C (puenteH). 

Estas funciones realizan un procesado similar a \textit{mover\_motor} y dan como resultado el número float de interés extraído de la cadena recibida para el caso de la función (cambiar\_constante), o el envío directo de la trama generada con ayuda de la función \textit{uart0\_tx\_buffer} de la librería \textit{uart.h} 


\subsection{Función myatof}

\begin{table}[H]
	\centering
	\caption{Descripción de Función myatof }
	\begin{tabular}{|l|l|}
		\hline
		Nombre de función: & myatof(char *p); \\
		\hline
		Descripción:  & Convierte de ascii a float\\
		\hline
		Parámetros: & char -- string a convertir \\
		\hline
		Resultado:  & valor convertido a float \\
		\hline
	\end{tabular}%
	\label{tab:func14}%
\end{table}%


Esta función se usa para convertir un caracter ASCII a un valor float. No se utiliza la función atof, de la librería \textit{stdlib.h}, ya que genera un error de compilación debido a que las funciones \textit{malloc} y \textit{free} están declaradas dentro del SDK como \textit{os\_malloc} y \textit{os\_free} y escritas de otra manera el compilador no las reconoce. Por lo tanto, se requirió un algoritmo que realizara el mismo proceso.




%Página Web
%Aplicación Android


